<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE>Open Systems Magazine: #2/93</TITLE>
   <META NAME="Author" CONTENT="Anatoli">
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0Gold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000">

<P><IMG SRC="../../os_all.gif" ALT="Top line" HEIGHT=28 WIDTH=500> 
<HR WIDTH="100%"><B><FONT SIZE=-1><A HREF="../index.html">Открытые Системы</A>
 # 2/93  стр. 41-47</FONT></B><FONT SIZE=-1> </FONT>
<HR width="100%"></P>

<H1>Обычный shell?</H1>

<ADDRESS>В.А. Галатенко</ADDRESS>

<DT>
<HR></DT>

<DT><B><FONT SIZE=-1><A HREF="#part_1">Введение</A></FONT></B></DT>

<DT><B><FONT SIZE=-1><A HREF="#part_2">Общий механизм выполнения команд</A></FONT></B></DT>

<DT><B><FONT SIZE=-1><A HREF="#part_3">Файлы, ассоциированные с процессом</A></FONT></B></DT>

<DT><B><FONT SIZE=-1><A HREF="#part_4">Конвейеры</A></FONT></B></DT>

<DT><B><FONT SIZE=-1><A HREF="#part_5">Переменные и аргументы shell-процедур</A></FONT></B></DT>

<DT><B><FONT SIZE=-1><A HREF="#part_6">Служебные переменные shell`а</A></FONT></B></DT>

<DT><B><FONT SIZE=-1><A HREF="#part_7">Подстановка результатов выполнения
команд</A></FONT></B></DT>

<DT><B><FONT SIZE=-1><A HREF="#part_8">Подстановка результатов выполнения
команд</A></FONT></B></DT>

<DT><B><FONT SIZE=-1><A HREF="#part_9">Генерация имен файлов</A></FONT></B></DT>

<DT><B><FONT SIZE=-1><A HREF="#part_10">Экранирование</A></FONT></B></DT>

<DT><B><FONT SIZE=-1><A HREF="#part_11">Переназначение ввода/вывода</A></FONT></B></DT>

<DT><B><FONT SIZE=-1><A HREF="#part_12">Окружение процессов</A></FONT></B></DT>

<DT><B><FONT SIZE=-1><A HREF="#part_13">Внутренние команды shell`а</A></FONT></B></DT>

<DT><B><FONT SIZE=-1><A HREF="#part_14">Резюме</A></FONT></B></DT>

<DT>
<HR></DT>

<P><B><I>В статье, носящей учебный характер, приводятся основные сведения
о стандартном командном интерпретаторе UNIX System V. Рассматриваются типичные
приемы программирования на языке shell. Приводятся примеры shell-процедур.</I></B></P>

<DIV ALIGN=right><P><I>При обращении с оболочкой следует соблюдать осторожность,
не допуская перегибов и чрезмерного напряжения.<BR>
Из руководства пользователя монгольфьеров</I></P></DIV>

<H3><A NAME="part_1"></A>Введение</H3>

<P>Интерфейс пользователя с операционной системой UNIX осуществляет специальная
программа, называемая shell (оболочка). После того, как пользователь вошел
в систему, он начинает взаимодействовать с этой программой. Shell не является
частью ядра операционной системы и не облаюает какими-либо особыми привилегиями
в смысле доступа к системным ресурсам. Ничто не мешает пользователю написать
свой интерпретатор.</P>

<P>Обычно в ОС UNIX доступны несколько интерпретаторов. Наиболее распространены
Bourne-shell (или просто shell, автор - Стив Баурн, AT&amp;T), С-shell
(Билл Джой, Университет Беркли), Korn-shell (Дэвид Корн, AT&amp;T). В идейном
плане эти интерпретаторы близки, и мы остановимся на стандартном shell`е
(программа /bin/sh) как наиболее простом и в то же время важным для системного
администрирования.</P>

<P>В простых случаях shell действительно играет роль оболочки, назначение
которой - ввести и обработать командную строку, выполнив предписанные подстановки,
а затем запустить нужную команду, дождаться ее завершения и перейти к чтению
следующей строки. В более сложных случаях shell делает кое-что сам - он
интерпретирует внутренние команды и управляющие конструкции. Таким образом,
за термином &quot;shell&quot; на самом деле скрываются две существенно
различные вещи: собственно командный интерпретатор и воспринимаемый им
язык.</P>

<P>В данной статье мы отвлечемся от интерфейсных возможностей интерпретатора,
связанных с вводом и редактированием команд, и сосредоточиться исключительно
на языковых аспектах. Мы попытаемся показать, что так называемых &quot;обычный
shell&quot; таит в себе массу красивых, плодотворных идей.</P>

<H3><A NAME="part_2"></A>Общий механизм выполнения команд</H3>

<P>Командная строка в языке shell - это последовательность слов, разделенных
пробелами. Первое слово определяет имя команды, которая будет выполняться;
оставшиеся слова, как правило, передаются команде в качестве аргументов.</P>

<P>Для выполнения (почти) каждой команды shell порождает отдельный процесс.
В рамках этого процесса выполняется программа, хранящаяся в файле, заданном
именем команды. Программа может быть выполняемой, то есть содержать машинные
инструкции, или же она может быть shell-процедурой, то есть содержать текст
на языке shell. В первом случае программа интерпретируется аппаратно, с
участием ядра операционной системы. Во втором случае программу интерпретирует
shell. Внешне отличия двух видов программ проявляются только в скорости
выполнения и в том, что shell-процедуры не нуждаются в компиляции и редактировании
связей (интерпретируется сам исходный текст).</P>

<P>Файл, содержащий программу, может храниться как в системном каталоге,
так и в личном каталоге пользователя и быть продуктом деятельности последнего.
У файла может быть произвольное имя. Тем самым набор команд языка shell
является расширяемым: его пополняет каждая новая программа, написанная
пользователем. Строго говоря, пополняет набор команд даже ссылка с новым
именем на уже существующий файл.</P>

<P>К сожалению, красивую идею выполнения всех команд в рамках порожденных
процессов не удастся провести в жизнь на 100%. Некоторые действия, в основном
касающиеся изменения внутреннего состояния, приходится брать на себя самому
shell`у. Например, если доверить порожденному процессу смену текущего каталога,
то процесс его, конечно, сменит (себе), после чего завершится с чувством
исполненного долга, а shell останется там, где и был. В результате с точки
зрения shell`а команды делятся на внешние (которые он только запускает)
и внутренние, которые ему приходится выполнять самому.</P>

<P>Выделив из введенной строки имя команды, shell сначала проверяет, не
является ли она внутренней, и только если это не так, приступает к поиску
соответствующего файла. Не следует давать своим выполняемым файлам имена
внутренних команд - в противном случае вызов этих файлов будет сопряжен
с трудностями. Если вы сомневаетесь, правильно ли shell воспринимает интересующее
вас имя команды, введите строку </P>

<PRE>type <I>имя</I></PRE>

<P>(type - внутренняя команда shell`а). shell отреагирует одним из трех
способов (строки, вводимы пользователем, начинаются с приглашения - $):
</P>

<PRE>$ type cd
cd is a shell builtin
$ type sh
sh is /bin/sh
$ type qq
qq not found</PRE>

<P>(cd - внутренняя команда, sh - программа, извлекаемая и каталога /bin,
файл с именем qq найти не удалось).</P>

<H3><A NAME="part_3"></A>Файлы, ассоциированные с процессом</H3>

<P>Как правило, с каждым процессом в ОС UNIX ассоциировано по крайней мере
три файла: </P>

<UL>
<LI>стандартный ввод. Отсюда читаются исходные данные. Сюда выдаются результаты.
</LI>

<LI>стандартный вывод. Сюда выдаются результаты. </LI>

<LI>стандартный протокол. Сюда выдаются диагностические сообщения.</LI>
</UL>

<P>По умолчанию стандартный ввод назначен на клавиатуру пользовательского
терминала, вывод и протокол - на экран. В следующих разделах будет рассказано,
как изменить эти значения.</P>

<H3><A NAME="part_4"></A>Конвейеры</H3>

<P>Главная сила UNIX`а проистекает не из мощи отдельных утилит, а из возможностей
их сопряжения. Конвейеры - один из самых красивых и продуктивных механизмов
подобного сопряжения.</P>

<P>Конвейер - это последовательность команд, разделенных знаком |. При
этом стандартный вывод всех команд, кроме последней, направляется на стандартный
ввод следующей команды конвейера. Каждая команда выполняется как самостоятельный
процесс; shell ожидает их завершения.</P>

<P>Соединение в конвейер даже относительно простых утилит способно дать
по существу новое качество. Так, команда ls не подсчитывает число файлов
в каталоге, а лишь выдает информацию о них. С другой стороны, команда wc
способна подсчитать число строк в файле, но не имеет отношения к распечатке
содержимого каталогов. Если же построить конвейер из двух упомянут </P>

<PRE>ls -a/ | wc -l</PRE>

<P>будет число элементов корневого каталога. Напомним, что команда wc,
вызванная без аргументов, подсчитывает число строк в файле стандартного
ввода, который в данном случае является результатом работы команды ls.</P>

<P>Еще один пример. Пусть нужно выдать информацию о файлах текущего каталога,
которые модифицировались в октябре. К цели ведет конвейер </P>

<PRE>ls -al | grep &quot;Oct&quot;</PRE>

<P>Команда grep играет здесь роль фильтра, который пропускает для вывода
только часть строк, выдаваемых ls.</P>

<P>Можно выстроить и трехступенчатый конвейер, если требуется подсчитать
число файлов, модифицированных в октябре: </P>

<PRE>ls -al | grep &quot;Oct&quot; | wc -l</PRE>

<P>Здесь команду grep с еще большим правом можно назвать фильтром.</P>

<P>Связующее звено между последовательными компонентами конвейера называется
каналом. Для интерпретации конвейера shell создает временный файл типа
&quot;канал&quot;, в который с одного конца информацию пишут, а с другого
конца - читают. С помощью команды tee можно организовать ответвление канала,
то есть помещать информацию не только на стандартный вывод, но и в указанные
файлы. Например, если нужно не только подсчитать число файлов из текущего
каталога, модифицированных в октябре, но и поместить информацию о них в
файл для последующего анализа, следует построить четырехступенчатый конвейер:
</P>

<PRE>ls -al|grep &quot;Oct&quot;|tree /tmp/tmpinf|wc -l</PRE>

<P>В результате выполнения этого конвейера на экране появится число нужных
файлов, а в файле /tmp/tmpinf - информация о них.</P>

<H3><A NAME="part_5"></A>Переменные и аргументы shell-процедур</H3>

<P>Переменные в языке shell, как, впрочем, и везде, обозначаются именами.
Значения могут присваиваться им привычным способом, то есть посредством
команд вида: </P>

<PRE><I>имя=значение</I></PRE>

<P>Все значения в языке shell трактуются как текстовые.</P>

<P>Обычно в языках программирования ясно из контекста, где имеется в виду
имя переменной, а где значение. Так, в левой части оператора присваивания
обычно используется имя, в правой - значение. В языке shell это не так.
Для обозначения перехода от имени переменной к значению используется явная
операция $. Если в команде встречается конструкция </P>

<PRE><I>$имя</I></PRE>

<P>то вместо нее интерпретатор shell подставляет значение переменной с
указанным именем. Допускается и запись </P>

<PRE>${<I>имя</I>}</PRE>

<P>с тем же смыслом, если нужно отделить имя от последующего текста.</P>

<P>Рассмотрим пример. После выполнения команд </P>

<PRE>a=value_of_variable
b=1+2
echo a=$a
echo b=$b</PRE>

<P>[команда echo (эхо) выдает на стандартный вывод свои аргументы] на экране
появится: </P>

<PRE>a=value_of_variable
b=1+2</PRE>

<P>Под shell-процедурой понимается файл, содержащий программу еа языке
shell. Значения формальных аргументов shell-процедур обозначаются как </P>

<PRE>$<I>цифра</I></PRE>

<P>$0 есть имя интерпретируемой shell-процедуры.</P>

<P>Рассмотрим shell-процедуру, которая выдает на стандартный вывод свое
имя и значения первых трех аргументов: </P>

<PRE>echo Имя команды: $0
echo Имя команды: $1
echo Имя команды: $2
echo Имя команды: $3</PRE>

<P>Пусть приведенный текст помещен в файл с именем three_args. Тогда в
результате выполнения команды </P>

<PRE>three_args arg1 . - arg4</PRE>

<P>на экране появится: </P>

<PRE>Имя команды: three_args
Значение первого аргумента: arg1
Значение второго аргумента: .
Значение третьего аргумента: -</PRE>

<P>Поскольку в тексте shell-процедуры упомянуты только первые 3 аргумента,
значения аргументов с большими номерами (даже если они заданы, как в приведенном
примере) не влияют на ее работу.</P>

<P>Команда </P>

<PRE>three_args arg1 --</PRE>

<P>выдаст: </P>

<PRE>Имя команды: three_args
Значение первого аргумента: arg1
начение второго аргумента: --
Значение третьего аргумента: </PRE>

<P>Значение третьего аргумента пусто.</P>

<P>Прежде чем начнется выполнение командной строки, то есть будет вызвана
заданная в ней команда, строка обрабатывается shell`ом, который выполняет
в ней некоторые подстановки. С одной из таких подстановок - значения переменной
вместо конструкции $имя - мы уже познакомились. Язык shell содержит ряд
аналогичных конструкций. Рассмотрим одну из них. Там, где в командной строке
встречается запись вида </P>

<PRE>${<I>имя:-слово</I>}</PRE>

<P>вместо нее подставляется значение переменной с указанным именем, если
это значение непусто; в противном случае подставляется в слово. Например,
если в shell-процедуре встретилось присваивание </P>

<PRE>initdir=${1:-/}</PRE>

<P>то переменная получит значение первого аргумента, если оно не пусто.
Если же процедуру вызвали без аргументов, значением initdir станет символ
/. Подобные конструкции - удобный способ задания подразумеваемых значений.</P>

<H3><A NAME="part_6"></A>Служебные переменные shell`а</H3>

<P>Значения некоторых переменных устанавливаются самим shell`ом. Перечислим
наиболее употребительные их этих переменных и опишем их предназначение.
# Количество фактических аргументов (десятичное). $ Идентификатор процесса,
в рамках которого выполняется shell. *, @ Совокупность всех фактических
аргументов (начиная с $1), разделенных пробелами. Напомним: чтобы получить
значения этих переменных, перед ними нужно поставить знак $.</P>

<P>Между значениями $@ и $* есть некоторые тонкие различия, на которых
мы останавливаться не будем.</P>

<P>Несколько усложним процедуру three_args, чтобы продемонстрировать только
что описанные возможности. </P>

<PRE>echo Идентификатор текущего процесса: $$
echo Имя команды: $0
echo Число фактических аргументов: $#
echo Совокупность всех аргументов: $@
echo Значение первого аргумента: $1
echo Значение второго аргумента: $2
echo Значение третьего аргумента: $3
</PRE>

<P>Если теперь выполнить командную строку </P>

<PRE>tree_args arg1 . - arg4</PRE>

<P>на экране появится примерно следующее: </P>

<PRE>Идентификатор текущего процесса: 168
Имя команды: tree_args
Число фактических аргументов: 4
Совокупность всех аргументов: arg1 . - arg4
Значение первого аргумента: agrl
Значение второго аргумента: .
Значение третьего аргумента: -</PRE>

<H3><A NAME="part_7"></A>Подстановка результатов выполнения команд</H3>

<P>Если в командной строке встретилась цепочка символов, заключенная в
обратные кавычки ("), эта цепочка интерпретируется как команда, стандартный
вывод которой подставляется вместо упомянутой конструкции. Говорят, что
в этом случае производится подстановка результатов выполнения команды,
а сами обратные кавычки называются символами подстановки.</P>

<P>Опишем один из употребительных способов использования подстановки результатов.
В языке shell все значения считаются текстовыми. Значит, для выполнения
операций с числами нужны особые средства. Команда expr рассматривает свои
аргументы как компоненты выражения и выдает результат вычисления этого
выражения на стандартный вывод. После выполнения строки </P>

<PRE>i=`expr $i + 1`</PRE>

<P>значение переменной i увеличится на 1.</P>

<H3><A NAME="part_8"></A>Подстановка результатов выполнения команд</H3>

<P>Язык shell, как и всякий универсальный язык программирования, представляет
ряд конструкций для управления последовательностью действий. Упомянем три
из них: </P>

<PRE>for <I>имя</I> in <I>слово</I> ...
do
<I>команда
</I>   .  .  .
else
<I>команда
</I>   .  .  .
fi</PRE>

<P>В качестве условия может фигурировать любая команда, однако в данном
контексте важен лишь код ее завершения. Если он нулевой, условие считается
истинным; в таком случае выполняется then-часть, иначе - else часть. Как
и в других языках, else-часть может отсутствовать.</P>

<P>Возможно также употребление связки elif (сокращение для else if). Отметим,
что чаще всего для проверки условия используется внутренняя команда shell`а
test. </P>

<PRE>while <I>условие</I> 
do 
<I>команда</I> 
   .  .  .
done</PRE>

<P>Пока условие истинно (то есть код завершения нулевой), выполняются команды
из тела цикла. При замене служебного слова while на until условие продолжения
цикла меняется на противоположное.</P>

<P>Приведем пример использования for-цикла. Усовершенствуем процедуру tree_args,
чтобы она выдавала значения всех, а не только первых трех аргументов: </P>

<PRE>echo Идентификатор текущего процесса: $$
echo Имя команды: $0
echo Число фактических аргументов: $#
echo Совокупность всех аргументов: $@
i=1
for arg
do
  echo Значение аргумента ${i}: $arg
i=`expr $i + 1`
done</PRE>

<H3><A NAME="part_9"></A>Генерация имен файлов</H3>

<P>После всех подстановок, прежде чем команда начнет выполняться, в каждом
ее составляющем слове ищутся символы *, ? и [. Если находится хотя бы один
из них, то это слово рассматривается как шаблон имен файлов и заменяется
именами файлов, удовлетворяющих данному шаблону. Файлы поставляются в алфавитном
порядке. Если ни одно имя файла не удовлетворяет шаблону, слово остается
неизменным. Трактовка символов *, ? и [: * Сопоставляется с произвольной
цепочкой символов, в том числе и с пустой. ? Сопоставляется с произвольным
символом. [...] Сопоставляется с любым из перечисленных в скобках символом.
Пара символов., разделенных знаком -, обозначает отрезок алфавита, включающий
сами указанные символы. Если сразу, вслед за [ идет !, шаблону удовлетворяет
любой символ, не перечисленный в скобках.</P>

<P>Рассмотрим несколько примеров. Чтобы подсчитать суммарное число строк
во всех фортрановских файлах текущего каталога, достаточно выполнить команду
</P>

<PRE>wc -l *.f</PRE>

<P>В качестве второго примера приведем фрагмент одного из стартовых файлов
ОС UNIX: </P>

<PRE>for f in/etc/rc2.d/S*
do
   /bin/sh ${f} start
done</PRE>

<P>В цикле будут в алфавитном порядке запускаться файлы из каталога /etc/rc2.d,
имена которых начинаются на S.</P>

<P>Теперь рассмотрим команду </P>

<PRE>rm -f .*.[Bb]</PRE>

<P>Она удалит из текущего каталога все файлы, имена которых начинаются
с точки, а сразу после второй точки стоит одна из букв - B или b, а затем
произвольный символ.</P>

<P>Читателю предлагается самостоятельно ответить на вопрос, удалит ли команда
</P>

<PRE>rm -f*.[Bb][AaUu]</PRE>

<P>файл с именем .bu.</P>

<H3><A NAME="part_10"></A>Экранирование</H3>

<P>Под экранированием будем понимать защиту от интерпретации shell`ом таких
символов, как пробел (разделитель слов в командной строке), *, ?, [(элементы
шаблона имен файлов) и некоторых других. Каждый из перечисленных символов
может быть экранирован, то есть представлять самого себя, если перед ним
стоит / или он расположен между кавычками ("" или &quot;&quot;).</P>

<P>Как всегда, приведем несколько примеров. Пусть нужно умножить значение
переменной i на 5. К цели ведет строка </P>

<PRE>i="expr $i \* 5"</PRE>

<P>Если звездочку не экранировать, shell подставит вместо нее имена файлов
текущего каталога. В результате выражение, являющееся аргументом команды
expr, скорее всего станет синтаксически некорректным.</P>

<P>Второй пример. Пусть нужно выдать информацию о всех файлах текущего
каталога, которые модифицировались последний раз 3 октября. Конвейер </P>

<PRE>ls -al | grep &quot;Oct 3&quot;</PRE>

<P>сделает то, что нужно. Кавычки использованы для экранирования двух пробелов
в разыскиваемой цепочке символов. Без них команда grep попыталась бы найти
текст Oct в файле с именем 3.</P>

<H3><A NAME="part_11"></A>Переназначение ввода/вывода</H3>

<P>Перед тем, как команда будет выполнена, ее ввод и вывод могут быть переназначены,
для чего используется специальная нотация, интерпретируемая shell`ом. Описанные
ниже конструкции могут располагаться в любом месте командной строки, могут
предшествовать команде или завершать ее и НЕ передаются в качестве аргументов.</P>

<P>&gt;<I>файл</I> Использовать заданный файл для стандартного вывода.
Если файла нет, он создается; если есть, он опустошается. &gt;&gt;<I>файл</I>
Использовать файл для стандартного вывода. Если файл существует, то выводимая
информация добавляется в конец; в противном случае файл создается. &lt;<I>файл</I>
Использовать файл для стандартного ввода. &lt;&lt;<I>слово</I> Читать информацию
из текущего файла стандартного ввода, пока не встретится строка, совпадающая
с заданным словом, или конец файла.</P>

<P>Если любой из этих конструкций предшествует цифра, она определяет дескриптор
(вместо подразумеваемых дескрипторов 0 или 1), который будет ассоциирован
с файлом, указанным в конструкции. Например, строка </P>

<PRE>... 2&gt;protocol</PRE>

<P>переназначает стандартный протокол (дескриптор 2) в файл по имени protocol.</P>

<P>Чтобы переназанчить стандартный протокол туда же, куда уже назначен
стандартный вывод, следует употребить конструкцию </P>

<PRE>... 2&gt;&amp;1</PRE>

<P>Приведем два примера. Пусть нужно измерить время выполнения некоторой
команды, направив ее результаты в файл cmd.res, а данные о времени - в
файл cmd.time. К цели ведет строка </P>

<PRE>time команда &gt;cmd.res 2&gt;cmd.time</PRE>

<P>Второй пример довольно сложен, но очень красив. Он заимствован из книги
&quot;B.W. Kernighan, R. Pike. The UNIX Progpamming Environment. - Prentice
Hall, 1984&quot;. Пусть нужно собрать воедино несколько файлов с возможностью
их последующей распаковки (подобная проблема встала, например, при передаче
по электронной почте содержимого целого каталога). Общая идея состоит в
том, чтобы результатом упаковки стала shell-процедура, разворачивающая
содержащую в ней информацию. Так сказать, мы хотим изготовить посылку,
которая сама себя откроет и выставит присланное на стол. И поможет нам
в этом чтение фрагмента стандартного ввода вплоть до указанного контекста
(конструкция &lt;<I>слово</I>). Отметим только, что строки комментария
в языке shell начинаются символом #.</P>

<P>Следующая shell-процедура, которую мы назовем sharc, объединяет файлы-аргументы
и выдает результат на стандартный вывод. </P>

<PRE>echo "# Вызвать данную shell-процедуру"
for i
do
    echo &quot;echo $i&gt;&amp;2&quot;
    echo &quot;cat &gt;$i &lt;&lt;"End of $i" &quot;
    cat $i
    echo &quot;End of $i&quot;
done</PRE>

<P>В цикле for последовательно обрабатываются аргументы процедуры. Для
каждого из них создается двухстрочный заголовок (echo ..., cat ...), после
которого помещается содержимое файла и хвостовик (End of ...).</P>

<P>Пусть, например, имеются два файла, a.sh: </P>

<PRE>ls *.txt</PRE>

<P>и b.sh: </P>

<PRE>echo $@</PRE>

<P>После выполнения командной строки </P>

<PRE>sharc a.sh b. b.sh &gt; arc.sh</PRE>

<P>в файле arc.sh окажется следующий текст: </P>

<PRE># Вызвать данную shell-процедуру
echo a.sh &gt;&amp;2
cat &gt;a.sh &lt;&lt;"End of a.sh"
ls *.txt
End of a.sh
echo b.sh &gt;&amp;2
cat &gt;b.sh &lt;&lt;"End of b.sh"
echo $@
End of b.sh</PRE>

<P>Если теперь переслать куда-нибудь файл arc.sh и там выполнить команды
</P>

<PRE>chmod +x arc/sh #Разрешить выполнение
arc.sh</PRE>

<P>произойдет выделение файлов и их наполнение нужным содержимым. Об этом
позаботятся команды вида </P>

<PRE>cat &gt;a.sh &lt;&lt;"End of a.sh"</PRE>

<P>которые прочитают после себя ровно столько строк, сколько нужно (данная
команда будет читать вплоть до строки End of a.sh), и направят их в соответствующий
файл (a.sh).</P>

<P>Обратите внимание на экранирование метасимволов от преждевременной интерпретации
shell`ом (нам нужно было поместить метасимволы, такие как &gt; и &lt;&lt;,
в результирующий файл), а также на то, что внутри двойных кавычек выполняется
подстановка значений переменных.</P>

<P>Читателю предлагается самостоятельно придумать способ борьбы с тем маловероятным
обстоятельством, что в тексте упаковываемого файла встретится строка <B>End
of</B> <I>имя_файла.</I></P>

<H3><A NAME="part_12"></A>Окружение процессов</H3>

<P>Окружение - это набор пар (имя, значение), который передается выполняемой
программе наряду со списком аргументов. Иными словами, порождаемые процессы
наследуют окружение процесса-предка. Компонентами окружения являются, помимо
прочих, следующие переменные и их значения: <B>HOME </B>Подразумеваемый
аргумент команды cd - основной каталог пользователя. <B>PATH</B> Список
имен каталогов для поиска команд. Элементы списка разделяются двоеточием.
Пустой элемент означает текущий каталог. <B>PS1</B> Основное приглашение
(по умолчанию &quot;$&quot;). <B>TERM</B> Тип пользовательского терминала.
<B>TZ</B> Информация о часовом поясе.</P>

<P>Чтобы выдать информацию об окружении на стандартный вывод, следует воспользоваться
командой </P>

<PRE>env</PRE>

<P>Поясним смысл переменных PATH и TZ.</P>

<P>Прежде чем выполнить команду, shell ищет файл, заданный простым именем,
в последовательности каталогов, являющейся значением переменной PATH. Естественно
назвать подобную последовательность списком поиска. Если, например, значение
$PATH суть </P>

<PRE>:/bin:/usr/bin:/usr/lbin</PRE>

<P>то нужный файл будет сначала разыскиваться в каталоге /bin и т.д. Как
только файл будет найден, поиск прекратится. Порядок задания элементов
списка поиска важен в тех случаях, когда разные каталоги содержат одноименные
выполняемые файлы.</P>

<P>Переменная TZ задает локальный часовой пояс. Первые три символа суть
имя часового пояса, следующие - разница между всемирный и локальным временем.
Например, значение </P>

<PRE>MDT-3</PRE>

<P>описывают часовой пояс Москвы. Разница со всемирным временем составляет
3 часа.</P>

<P>Для изменения окружения мало присвоить новое значение соответствующей
переменной. Дело в том, что по умолчанию переменные считаются локальными
по отношению к shell-процедуре, то есть присваивание изменит локальную
переменную, но не затронет одноименную переменную окружения. В результате
в окружение новых процессов (порожденных, например, для выполнения последующих
команд данной shell-процедуры) войдет переменная со старым значением.</P>

<P>Чтобы лучше уяснить ситуацию, рассмотрим пример. Пусть есть две shell-процедуры
- proc1 и proc2. </P>

<PRE># Процедура proc1
TZ=MEZ-1
echo Из proc1: $TZ
proc 2</PRE>

<P>Пусть стандартное значение переменной TZ есть MDT-3. В результате выполнения
процедуры proc1 на экране появится: </P>

<PRE>Из proc1: MEZ-1
Из proc2: MDT-3</PRE>

<P>то есть порожденный процесс унаследовал стандартное значение переменной
окружения TZ.</P>

<P>С помощью конструкции </P>

<PRE>export <I>имя</I></PRE>

<P>переменная с указанным именем помещается в окружение, то есть становится
глобальной. Например, обычно shell-процедура /etc/profile, которая выполняется
как составная часть процесса входа пользователя в систему, содержит строки
вида: </P>

<PRE>export PATH
PATH=...</PRE>

<P>Первая строка вызывает отождествление глобальной и локальной переменной
PATH, вторая присвоит переменной PATH новое значение. Измененное значение
$PATH становится компонентом окружения и будет унаследовано порождаемыми
процессами.</P>

<P>Вернемся к процедуре proc1 и добавим в нее команду export: </P>

<PRE># Процедура proc1
export TZ
TZ=MEZ-1
echo Из proc1: $TZ
proc2</PRE>

<P>Теперь в результате выполнения процедуры proc1 на экране появится: </P>

<PRE>Из proc1: MEZ-1
Из proc2: MEZ-1</PRE>

<P>Мы видим, что окружение изменилось.</P>

<H3><A NAME="part_13"></A>Внутренние команды shell`а</H3>

<P>Выше мы уже отмечали необходимость существования внутренних команд,
интерпретацию которых shell берет на себя. Вот их краткий перечень: </P>

<UL>
<LI><I>. файл</I> - текстовая подстановка заданного файла </LI>

<LI><I>break</I> - выйти из цикла </LI>

<LI><I>continue</I> - перейти к следующей итерации цикла </LI>

<LI><I>cd</I> - сменит текущий каталог </LI>

<LI><I>echo</I> - выдать аргументы на стандартный вывод </LI>

<LI><I>eval</I> - выполнить заданную команду </LI>

<LI><I>exec</I> - сменить программу процесса </LI>

<LI><I>exit</I> - завершить выполнение shell`а </LI>

<LI><I>getopts</I> - разобрать командную строку </LI>

<LI><I>pwd</I> -выдать имя текущего каталога </LI>

<LI><I>read</I> - прочитать строку и разделить ее на слова </LI>

<LI><I>return</I> - выйти из функции </LI>

<LI><I>set</I> - изменить внутренние переменные shell`а </LI>

<LI><I>shift</I> - переименовать формальные аргументы </LI>

<LI><I>test</I> - вычислить условное выражение </LI>

<LI><I>trap</I> - установить реакцию на сигналы </LI>

<LI><I>type</I> - выдать способ интерпретации имени shell`ом </LI>

<LI><I>ulimit</I> - установить максимальный размер файлов </LI>

<LI><I>umask</I> - установить маску</LI>
</UL>

<P>Сделаем некоторые пояснения. С помощью команды exec можно сменить программу
текущего процесса. Например, если пользователь привык работать в С-shell`е
(программа /bin/csh), то он может перейти туда по команде </P>

<PRE>exec csh</PRE>

<P>При этом обычный shell бесследно исчезнет.</P>

<P>Команда read позволяет читать информацию со стандартного ввода и разбивать
его на слова. При достижении конца файла read возвращает ненулевой код
завершения. Читателю предлагается самостоятельно убедиться в том, что shell-процедура,
содержащая текст </P>

<PRE>who|while read a b c; do cat $* &gt;/dev/$b &amp;done</PRE>

<P>обеспечивает рассылку файлов-аргументов на все терминалы, за которыми
в данный момент кто-то работает (команда who без аргументов выдает список
пользователей вместе с именами терминалов, за которыми они сидят, и некоторой
дополнительной информацией).</P>

<P>Важную роль играет еще одна внутренняя команда - set. Она используется
для изменения режима работы shell`а и для присваивания новых значений формальным
аргументам. Сразу же отметим, что наивное присваивание </P>

<PRE><I>цифра=слово</I></PRE>

<P>трактуется shell`ом как запуск программы с именем цифра=слово, то есть
оно не позволяет изменить значение формального аргумента.</P>

<P>Команда set записывается в виде </P>

<PRE>set <I>опция... аргумент...</I></PRE>

<P>Из опций упомянем только одну: -х Выодить команды и их аргументы непосредственно
перед выполнением. После выполнения команды </P>

<PRE>set -x</PRE>

<P>будет производиться трассировка текущей shell-процедуры. Чтобы прекратить
трассировку, нужно воспользоваться командой </P>

<PRE>set +x</PRE>

<P>Если в команде set заданы аргументы, они станут новыми значениями $1,
$2 и т.д. Рассмотрим фрагмент shell-процедуры /etc/rc2, которая выполняется
в процессе загрузки системы: </P>

<PRE>set"who -r"
if [ $9 = &quot;S&quot; ]
...</PRE>

<P>Команда who -r выдаст строку следующего вида: </P>

<PRE>. run-level 2 Oct 17 09:56 2 0 S</PRE>

<P>Слова из этой строки станут аргументами команды set. В результате значением
$1 станет точка, значением $2 - слово run-level, ..., значением $9 - S,
так что проверяемое условие окажется истинным.</P>

<H3><A NAME="part_14"></A>Резюме</H3>

<P>Shell - мощный язык программирования. Обратим внимание на имеющиеся
в нем возможности по комбинированию команд с помощью конвейеров, на подстановки
значений переменных и результатов выполнения команд, на генерацию имен
файлов по шаблонам.</P>

<P>
<HR WIDTH="100%"><B><FONT SIZE=-1><A HREF="../index.html">Открытые Системы</A>
 # 2/93</FONT></B><FONT SIZE=-1> </FONT>
<HR WIDTH="100%"><IMG SRC="../../os_allb.gif" ALT="Bottom line" HEIGHT=28 WIDTH=500></P>

</BODY>
</HTML>
